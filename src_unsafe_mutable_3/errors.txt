   Compiling rust_spreadsheet v0.1.0 (/home/asterisk/code/rust/projects/rust_spreadsheet)
warning: unused imports: `ExecutableCommand` and `terminal`
 --> src/main.rs:2:17
  |
2 | use crossterm::{terminal, ExecutableCommand};
  |                 ^^^^^^^^  ^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unused import: `crate::basic::swap_char`
 --> src/convert.rs:5:5
  |
5 | use crate::basic::swap_char;
  |     ^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::f64::consts::E`
 --> src/formulas.rs:6:5
  |
6 | use std::f64::consts::E;
  |     ^^^^^^^^^^^^^^^^^^^

warning: unused imports: `StatusCode` and `set_status_code`
 --> src/parser.rs:9:21
  |
9 | use crate::status::{set_status_code, StatusCode};
  |                     ^^^^^^^^^^^^^^^  ^^^^^^^^^^

warning: unused import: `std::cell::RefCell`
 --> src/sheet.rs:2:5
  |
2 | use std::cell::RefCell;
  |     ^^^^^^^^^^^^^^^^^^

warning: unused import: `std::rc::Rc`
 --> src/sheet.rs:5:5
  |
5 | use std::rc::Rc;
  |     ^^^^^^^^^^^

warning: unused import: `info::CommandInfo`
  --> src/main.rs:21:5
   |
21 | use info::CommandInfo;
   |     ^^^^^^^^^^^^^^^^^

warning: value assigned to `print_header` is never read
  --> src/compare.rs:48:17
   |
48 |                 print_header = false;
   |                 ^^^^^^^^^^^^
   |
   = help: maybe it is overwritten before being read?
   = note: `#[warn(unused_assignments)]` on by default

warning: value assigned to `print_header` is never read
  --> src/compare.rs:67:17
   |
67 |                 print_header = false;
   |                 ^^^^^^^^^^^^
   |
   = help: maybe it is overwritten before being read?

warning: unused variable: `mem_pool`
   --> src/graph.rs:134:59
    |
134 |         self.modify_graph(cell, &cell_info, |head, value, mem_pool| {
    |                                                           ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_mem_pool`
    |
    = note: `#[warn(unused_variables)]` on by default

warning: variable does not need to be mutable
   --> src/graph.rs:130:13
    |
130 |         let mut sheet_borrow = self.sheet.borrow_mut();
    |             ----^^^^^^^^^^^^
    |             |
    |             help: remove this `mut`
    |
    = note: `#[warn(unused_mut)]` on by default

warning: unused variable: `mem_pool`
   --> src/graph.rs:141:57
    |
141 |         self.modify_graph(cell, new_info, |head, value, mem_pool| {
    |                                                         ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_mem_pool`

warning: variable does not need to be mutable
   --> src/graph.rs:252:17
    |
252 |             let mut sheet_borrow = self.sheet.borrow_mut();
    |                 ----^^^^^^^^^^^^
    |                 |
    |                 help: remove this `mut`

warning: variable does not need to be mutable
  --> src/list.rs:92:9
   |
92 |     let mut pool = unsafe { &mut crate::list::MEM_POOL };
   |         ----^^^^
   |         |
   |         help: remove this `mut`

warning: unused variable: `caps`
   --> src/parser.rs:140:18
    |
140 | fn handle_scroll(caps: &regex::Captures, info: &mut Info) -> Result<(), ParseError> {
    |                  ^^^^ help: if this is intentional, prefix it with an underscore: `_caps`

warning: unused variable: `info`
   --> src/parser.rs:140:42
    |
140 | fn handle_scroll(caps: &regex::Captures, info: &mut Info) -> Result<(), ParseError> {
    |                                          ^^^^ help: if this is intentional, prefix it with an underscore: `_info`

warning: function `swap_char` is never used
  --> src/basic.rs:31:8
   |
31 | pub fn swap_char(a: &mut u8, b: &mut u8) {
   |        ^^^^^^^^^
   |
   = note: `#[warn(dead_code)]` on by default

warning: function `swap_int` is never used
  --> src/basic.rs:35:8
   |
35 | pub fn swap_int(a: &mut i32, b: &mut i32) {
   |        ^^^^^^^^

warning: constant `MAXLEN` is never used
 --> src/compare.rs:5:7
  |
5 | const MAXLEN: usize = 19; // Read up to 19 bytes per chunk (like C's fgets with buffer size 20)
  |       ^^^^^^

warning: function `compare` is never used
 --> src/compare.rs:7:4
  |
7 | fn compare(f1name: &str, f2name: &str) -> io::Result<i32> {
  |    ^^^^^^^

warning: function `main` is never used
  --> src/compare.rs:96:4
   |
96 | fn main() -> io::Result<()> {
   |    ^^^^

warning: function `is_arithmetic_function` is never used
  --> src/formulas.rs:30:8
   |
30 | pub fn is_arithmetic_function(i: u8) -> bool {
   |        ^^^^^^^^^^^^^^^^^^^^^^

warning: function `is_single_arg_function` is never used
  --> src/formulas.rs:34:8
   |
34 | pub fn is_single_arg_function(i: u8) -> bool {
   |        ^^^^^^^^^^^^^^^^^^^^^^

warning: methods `is_cell_arg1`, `is_cell_arg2`, and `is_cell_both` are never used
  --> src/info.rs:13:12
   |
12 | impl Info {
   | --------- methods in this implementation
13 |     pub fn is_cell_arg1(&self) -> bool {
   |            ^^^^^^^^^^^^
...
17 |     pub fn is_cell_arg2(&self) -> bool {
   |            ^^^^^^^^^^^^
...
21 |     pub fn is_cell_both(&self) -> bool {
   |            ^^^^^^^^^^^^

warning: field `next` is never read
  --> src/list.rs:16:9
   |
14 | pub struct Block {
   |            ----- field in this struct
15 |     pub nodes: Vec<Rc<RefCell<Node>>>,
16 |     pub next: Option<Rc<RefCell<Block>>>,
   |         ^^^^
   |
   = note: `Block` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis

warning: methods `destroy` and `free` are never used
  --> src/list.rs:63:12
   |
26 | impl ListMemPool {
   | ---------------- methods in this implementation
...
63 |     pub fn destroy(&mut self) {
   |            ^^^^^^^
...
84 |     pub fn free(&mut self, node: Rc<RefCell<Node>>) {
   |            ^^^^

warning: constant `INPUT_BUFFER_SIZE` is never used
  --> src/parser.rs:11:7
   |
11 | const INPUT_BUFFER_SIZE: usize = 64;
   |       ^^^^^^^^^^^^^^^^^

warning: constant `MAX_MATCHES` is never used
  --> src/parser.rs:12:7
   |
12 | const MAX_MATCHES: usize = 4;
   |       ^^^^^^^^^^^

warning: variant `ParseFailure` is never constructed
  --> src/parser.rs:34:5
   |
29 | pub enum ParseError {
   |          ---------- variant in this enum
...
34 |     ParseFailure,
   |     ^^^^^^^^^^^^
   |
   = note: `ParseError` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis

warning: function `parse_sheet_dimensions` is never used
  --> src/parser.rs:53:8
   |
53 | pub fn parse_sheet_dimensions(n_str: &str, m_str: &str) -> Result<(usize, usize), ParseError> {
   |        ^^^^^^^^^^^^^^^^^^^^^^

warning: methods `set_position`, `scroll`, `is_valid_cell`, `is_valid_range`, `get_row`, and `set` are never used
   --> src/sheet.rs:36:12
    |
22  | impl Sheet {
    | ---------- methods in this implementation
...
36  |     pub fn set_position(&mut self, x: usize, y: usize) -> Result<(), StatusCode> {
    |            ^^^^^^^^^^^^
...
46  |     pub fn scroll(&mut self, dx: isize, dy: isize) -> Result<(), StatusCode> {
    |            ^^^^^^
...
83  |     pub fn is_valid_cell(&self, r: usize, c: usize) -> bool {
    |            ^^^^^^^^^^^^^
...
87  |     pub fn is_valid_range(&self, cell1: usize, cell2: usize) -> bool {
    |            ^^^^^^^^^^^^^^
...
93  |     pub fn get_row(&self, cell: usize) -> usize {
    |            ^^^^^^^
...
115 |     pub fn set(&mut self, cell: usize, info: CellInfo) {
    |            ^^^

warning: variants `Overflow`, `InvalidCell`, `InvalidRange`, `OutOfBounds`, and `InvalidValue` are never constructed
  --> src/status.rs:10:5
   |
7  | pub enum StatusCode {
   |          ---------- variants in this enum
...
10 |     Overflow,
   |     ^^^^^^^^
11 |     InvalidCell,
   |     ^^^^^^^^^^^
12 |     InvalidRange,
   |     ^^^^^^^^^^^^
13 |     CyclicDep,
14 |     OutOfBounds,
   |     ^^^^^^^^^^^
15 |     InvalidValue,
   |     ^^^^^^^^^^^^
   |
   = note: `StatusCode` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: function `get_status_code` is never used
  --> src/status.rs:43:8
   |
43 | pub fn get_status_code() -> StatusCode {
   |        ^^^^^^^^^^^^^^^

warning: field `container` is never read
 --> src/vector.rs:4:5
  |
3 | pub struct Vector {
  |            ------ field in this struct
4 |     container: Vec<i32>,
  |     ^^^^^^^^^
  |
  = note: `Vector` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis

warning: multiple associated items are never used
  --> src/vector.rs:8:12
   |
7  | impl Vector {
   | ----------- associated items in this implementation
8  |     pub fn new() -> Self {
   |            ^^^
...
14 |     pub fn resize(&mut self, new_capacity: usize) -> bool {
   |            ^^^^^^
...
22 |     pub fn push_back(&mut self, value: i32) -> bool {
   |            ^^^^^^^^^
...
27 |     pub fn back(&self) -> Option<&i32> {
   |            ^^^^
...
31 |     pub fn pop_back(&mut self) {
   |            ^^^^^^^^
...
38 |     pub fn erase(&mut self, key: i32) -> bool {
   |            ^^^^^
...
47 |     pub fn print(&self) {
   |            ^^^^^

error: creating a mutable reference to mutable static is discouraged
   --> src/graph.rs:316:30
    |
316 |         if let Some(graph) = &mut GRAPH {
    |                              ^^^^^^^^^^ mutable reference to mutable static
    |
    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/static-mut-references.html>
    = note: mutable references to mutable statics are dangerous; it's undefined behavior if any other pointer to the static is used or if any other reference is created for the static while the mutable reference lives
    = note: `#[deny(static_mut_refs)]` on by default
help: use `&raw mut` instead to create a raw pointer
    |
316 |         if let Some(graph) = &raw mut GRAPH {
    |                              ~~~~~~~~

error: creating a mutable reference to mutable static is discouraged
  --> src/list.rs:92:29
   |
92 |     let mut pool = unsafe { &mut crate::list::MEM_POOL };
   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^ mutable reference to mutable static
   |
   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/static-mut-references.html>
   = note: mutable references to mutable statics are dangerous; it's undefined behavior if any other pointer to the static is used or if any other reference is created for the static while the mutable reference lives
help: use `&raw mut` instead to create a raw pointer
   |
92 |     let mut pool = unsafe { &raw mut crate::list::MEM_POOL };
   |                             ~~~~~~~~

error: creating a mutable reference to mutable static is discouraged
   --> src/list.rs:142:9
    |
142 |         MEM_POOL.add_block();
    |         ^^^^^^^^^^^^^^^^^^^^ mutable reference to mutable static
    |
    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/static-mut-references.html>
    = note: mutable references to mutable statics are dangerous; it's undefined behavior if any other pointer to the static is used or if any other reference is created for the static while the mutable reference lives

warning: `rust_spreadsheet` (bin "sheet") generated 35 warnings
error: could not compile `rust_spreadsheet` (bin "sheet") due to 3 previous errors; 35 warnings emitted
